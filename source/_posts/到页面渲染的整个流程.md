---
title: 输入url到页面渲染的整个过程
date: 2019-03-30 18:59:07
tags: 
- 浏览器
- javascript
- http
categories: 前端
---
# 浏览器接收url到开启网络请求线程

## 多进程的浏览器

浏览器是多进程的，进程包括
<!-- more -->
- Browser进程：浏览器的主进程（负责协调、主控），只有一个。作用有
  - 负责浏览器界面显示，与用户交互。如前进，后退等
  - 负责各个页面的管理，创建和销毁其他进程
  - 将Renderer进程得到的内存中的Bitmap，绘制到用户界面上
  - 网络资源的管理，下载等

- 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建
- GPU进程：最多一个，用于3D绘制等
- 浏览器渲染进程（浏览器内核）（Renderer进程，内部是多线程的）：默认每个Tab页面一个进程，互不影响，当然，浏览器有时会将多个进程合并。主要作用为
  - 页面渲染，脚本执行，事件处理等

## 多线程的浏览器内核

每一个tab页面可以看作是浏览器内核进程，然后这个进程是多线程的，它有几大类子线程

- GUI渲染线程
  - 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。
  - 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行
  - 注意，**GUI渲染线程与JS引擎线程是互斥的**，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中**等到JS引擎空闲时**立即被执行。
- JS引擎线程
  - 也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）
  - JS引擎线程负责解析Javascript脚本，运行代码。
  - JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序
  - 同样注意，**GUI渲染线程与JS引擎线程是互斥的**，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。
- 事件触发线程

  - 归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）
  - 当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中
  - 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理
  - 注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）
- 定时触发器线程
  - 传说中的`setInterval`与`setTimeout`所在线程
  - 浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）
  - 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）
  - 注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。
- 异步http请求线程
  - 在XMLHttpRequest在连接后是通过浏览器新开一个线程请求
  - 将检测到状态变更时，如果设置有回调函数，异步线程就**产生状态变更事件**，将这个回调再放入事件队列中。再由JavaScript引擎执行。

## 解析URL

输入URL后，会进行解析（URL的本质就是统一资源定位符）

URL一般包括几大部分：

- `protocol`，协议头，譬如有http，ftp等
- `host`，主机域名或IP地址
- `port`，端口号
- `path`，目录路径
- `query`，即查询参数
- `fragment`，即`#`后的hash值，一般用来定位到某个位置

## 网络请求都是单独的线程

每次网络请求时都需要开辟单独的线程进行，譬如如果URL解析到http协议，就会新建一个网络线程去处理资源下载

# 开启网络线程到发出一个完整的http请求


## DNS解析

首先是 DNS 查询，会提供访问速度最快的 IP 地址回来

DNS 是 Domain Name System 的缩写，作用很简单，根据域名查询对应的 IP 地址。

### 为什么要有 DNS

TCP/IP 约定每个网络请求包根据 IP 地址确认接收方。这和你打电话需要知道对方电话号码一样。

因为 IP 存在数字和英文的组合（IPv6），很不利于人类记忆，所以就出现了域名。你可以把域名看成是某个 IP 的别名，DNS 就是去查询这个别名的真正名称是什么。

**为什么不设计成直接根据域名确认接收方呢？**

在 iPv4 里，IP 地址是 4 个 0-255 的数，2 的 8 次方，8 bit，1 byte。只要 4 个字节的大小。 如果是支持字符串，就算用最简单的 ASCII 编码，一个字符就要 1 个字节。一个常见的域名通常十几个字符，最长可以支持 255 个字符，比用 IP 表示大了很多倍。

有的人可能觉得虽然大了很多倍，但是如果只是一个请求大了几个字节性能影响也不大。这里面还有一个误区，TCP/IP 只是一个协议，网络中和通讯有关设备是多种多样的。比如我发送一个 5 KB 的字符串，中间有可能通过光纤传递传递，也有可能通过早期的铜缆。不同的连接材料的带宽区别很大。有可能一个包的 maxSize 只能是 1 KB（IP 层的 MTU）。应用层的数据在通讯过程中会根据通讯设备的带宽分成很多个包。一个 http 请求并不是只发了一个包，可能一次请求被拆成了很多个包。所以如果用域名，网络请求的数据量会增加很多。

### DNS 如何工作

在 TCP 握手之前就已经进行了 DNS 查询，这个查询是操作系统自己做的。

### 不是一台服务器，是分布式服务器

互联网中有那么多的域名，全部都存在一台服务器中显然是不可能的。全世界每天有那么多的域名新增、修改，如果全往一台服务器做 IO ，性能多强也扛不住。

DNS 是分层的数据库结构。

比如一个域名 `www.google.com`, 分成了4层：根域名、com、google、www。根域名是用`.`表示，因为域名的最后的`.`可以被忽略，所有常常被人遗忘，完整的域名表示是`www.google.com.`。

当你在浏览器中想访问 `www.google.com` 时，会进行一下操作：

1. 操作系统会首先在本地缓存中查询 IP
2. 没有的话会去系统配置的 DNS 服务器中查询
3. 如果这时候还没得话，会直接去 DNS 根服务器查询，这一步查询会找出负责 `com` 这个一级域名的服务器
4. 然后去该服务器查询 `google` 这个二级域名
5. 如果我们持有 google域名，google 下的子域名我们可以自己控制。有两种控制方式，一种是直接把子域名一起注册到 google域名里，记录在 com 域名服务器下。一种是自建 name server。此时向 com 域名查询 google，会返回你自己配置的 name server 服务器地址，解析就由你自己控制了。

自建 name server 通常是对域名商的 ns 性能不满意。[《DNS 基础知识》](https://juejin.im/post/59c6201df265da064428b835)里提到：

> 虽然顶级域名注册商都有自己的 nameserver, 但注册商提供的 nameserver  并不专业，在性能和稳定性上无法满足企业需求，这时就需要企业搭建自己的高性能 nameserver ，比如增加智能解析功能，让不同地域的用户访问最近的 IP，以此来提高服务质量。

### DNS 不仅只是查询 IP

除了域名解析的 A 记录。还包括了 MX（Mail eXchange）邮件服务器地址，还有别名 CNAME 记录。 实际上还有很多其他功能，比如根据 IP 地址反查域名（PTR），查询域名 DNS 服务器 IP 地址（NS）。

## 建立TCP链接

客户端发送一个带有SYN标志的数据包给服务端，服务端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息，最后客户端再回传一个带ACK标志的数据包，代表握手结束，连接成功。

上图也可以这么理解：

客户端：“你好，在家不，有你快递。”

服务端：“在的，送来就行。”

客户端：“好嘞。”

> 为了避免服务器与客户端双方的资源占用和损耗，当双方没有请求或响应传递时，任意一方都可以发起关闭请求。与创建TCP连接的3次握手类似，关闭TCP连接，需要4次挥手。
>
> 客户端：“兄弟，我这边没数据要传了，咱关闭连接吧。”
>
> 服务端：“收到，我看看我这边有木有数据了。”
>
> 服务端：“兄弟，我这边也没数据要传你了，咱可以关闭连接了。”
>
> 客户端：“好嘞。”

## 发送HTTP请求

与服务器建立了连接后，就可以向服务器发起请求了

# 从服务器接收到请求到对应后台接收到请求

## 负载均衡

对于大型的项目，由于并发访问量很大，所以往往一台服务器是吃不消的，所以一般会有若干台服务器组成一个集群，然后配合反向代理实现负载均衡

当然了，负载均衡不止这一种实现方式，这里不深入...

简单的说：

**用户发起的请求都指向调度服务器（反向代理服务器，譬如安装了nginx控制负载均衡），然后调度服务器根据实际的调度算法，分配不同的请求给对应集群中的服务器执行，然后调度器等待实际服务器的HTTP响应，并将它反馈给用户**

## 后台的处理

一般后台都是部署到容器中的，所以一般为：

- 先是容器接受到请求（如tomcat容器）
- 然后对应容器中的后台程序接收到请求（如java程序）
- 然后就是后台会有自己的统一处理，处理完后响应响应结果

概括下：

- 一般有的后端是有统一的验证的，如安全拦截，跨域验证
- 如果这一步不符合规则，就直接返回了相应的http报文（如拒绝请求等）
- 然后当验证通过后，才会进入实际的后台代码，此时是程序接收到请求，然后执行（譬如查询数据库，大量计算等等）
- 等程序执行完毕后，就会返回一个http响应包（一般这一步也会经过多层封装）
- 然后就是将这个包从后端发送到前端，完成交互

## 后台和前台的http交互

前后端交互时，http报文作为信息的载体，有专门文章介绍

# 解析页面流程

## 流程简述

浏览器内核拿到内容后，渲染步骤大致可以分为以下几步：

```js
1. 解析HTML，构建DOM树

2. 解析CSS，生成CSS规则树

3. 合并DOM树和CSS规则，生成render树

4. 布局render树（Layout/reflow），负责各元素尺寸、位置的计算

5. 绘制render树（paint），绘制页面像素信息

6. 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上
```

![](C:\mdDocument\面试秘籍\img\页面流程.jpg)

## HTML解析，构建DOM

整个渲染步骤中，HTML解析是第一步。

简单的理解，这一步的流程是这样的：**浏览器解析HTML，构建DOM树。**

但实际上，在分析整体构建时，却不能一笔带过，得稍微展开。

解析HTML到构建出DOM当然过程可以简述如下：

```js
Bytes → characters → tokens → nodes → DOM
```

譬如假设有这样一个HTML页面：（以下部分的内容出自参考来源，修改了下格式）

```html
<html>
  <head>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <link href="style.css" rel="stylesheet">
    <title>Critical Path</title>
  </head>
  <body>
    <p>Hello <span>web performance</span> students!</p>
    <div><img src="awesome-photo.jpg"></div>
  </body>
</html>
```

浏览器的处理如下：

![](C:\mdDocument\面试秘籍\img\html解析.jpg)

列举其中的一些重点过程：

```js
1. Conversion转换：浏览器将获得的HTML内容（Bytes）基于他的编码转换为单个字符

2. Tokenizing分词：浏览器按照HTML规范标准将这些字符转换为不同的标记token。每个token都有自己独特的含义以及规则集

3. Lexing词法分析：分词的结果是得到一堆的token，此时把他们转换为对象，这些对象分别定义他们的属性和规则

4. DOM构建：因为HTML标记定义的就是不同标签之间的关系，这个关系就像是一个树形结构一样
例如：body对象的父节点就是HTML对象，然后段略p对象的父节点就是body对象
```

最后的DOM树如下：

![](C:\mdDocument\面试秘籍\img\dom生成.jpg)

## 生成CSS规则

同理，CSS规则树的生成也是类似。简述为：

```js
Bytes → characters → tokens → nodes → CSSOM
```

譬如`style.css`内容如下：

```js
body { font-size: 16px }
p { font-weight: bold }
span { color: red }
p span { display: none }
img { float: right }
```

那么最终的CSSOM树就是：

![](C:\mdDocument\面试秘籍\img\cssom.jpg)

## 构建渲染树

当DOM树和CSSOM都有了后，就要开始构建渲染树了

一般来说，渲染树和DOM树相对应的，但不是严格意义上的一一对应

因为有一些不可见的DOM元素不会插入到渲染树中，如head这种不可见的标签或者`display: none`等

整体来说可以看图：

![](C:\mdDocument\面试秘籍\img\rendertree.jpg)

## 渲染

有了render树，接下来就是开始渲染，基本流程如下：

![](C:\mdDocument\面试秘籍\img\render.jpg)

图中重要的四个步骤就是：

```js
1. 计算CSS样式

2. 构建渲染树

3. 布局，主要定位坐标和大小，是否换行，各种position overflow z-index属性

4. 绘制，将图像绘制出来
```

然后，图中的线与箭头代表通过js动态修改了DOM或CSS，导致了重新布局（Layout）或渲染（Repaint）

这里Layout和Repaint的概念是有区别的：

- Layout，也称为Reflow，即回流。一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树
- Repaint，即重绘。意味着元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就可以了

回流的成本开销要高于重绘，而且一个节点的回流往往回导致子节点以及同级节点的回流，
所以优化方案中一般都包括，尽量避免回流。

**什么会引起回流？**

```js
1.页面渲染初始化

2.DOM结构改变，比如删除了某个节点

3.render树变化，比如减少了padding

4.窗口resize

5.最复杂的一种：获取某些属性，引发回流，
很多浏览器会对回流做优化，会等到数量足够时做一次批处理回流，
但是除了render树的直接变化，当获取一些属性时，浏览器为了获得正确的值也会触发回流，这样使得浏览器优化无效，包括
    （1）offset(Top/Left/Width/Height)
     (2) scroll(Top/Left/Width/Height)
     (3) cilent(Top/Left/Width/Height)
     (4) width,height
     (5) 调用了getComputedStyle()或者IE的currentStyle
```

回流一定伴随着重绘，重绘却可以单独出现

所以一般会有一些优化方案，如：

- 减少逐项更改样式，最好一次性更改style，或者将样式定义为class并一次性更新
- 避免循环操作dom，创建一个documentFragment或div，在它上面应用所有DOM操作，最后再把它添加到window.document
- 避免多次读取offset等属性。无法避免则将它们缓存到变量
- 将复杂的元素绝对定位或固定定位，使得它脱离文档流，否则回流代价会很高

**注意：改变字体大小会引发回流**

再来看一个示例：

```js
var s = document.body.style;

s.padding = "2px"; // 回流+重绘
s.border = "1px solid red"; // 再一次 回流+重绘
s.color = "blue"; // 再一次重绘
s.backgroundColor = "#ccc"; // 再一次 重绘
s.fontSize = "14px"; // 再一次 回流+重绘
// 添加node，再一次 回流+重绘
document.body.appendChild(document.createTextNode('abc!'));
```

## 简单层与复合层

上述中的渲染中止步于绘制，但实际上绘制这一步也没有这么简单，它可以结合复合层和简单层的概念来讲。

这里不展开，进简单介绍下：

- 可以认为默认只有一个复合图层，所有的DOM节点都是在这个复合图层下的
- 如果开启了硬件加速功能，可以将某个节点变成复合图层
- 复合图层之间的绘制互不干扰，由GPU直接控制
- 而简单图层中，就算是absolute等布局，变化时不影响整体的回流，但是由于在同一个图层中，仍然是会影响绘制的，因此做动画时性能仍然很低。而复合层是独立的，所以一般做动画推荐使用硬件加速

## 资源外链的下载

上面介绍了html解析，渲染流程。但实际上，在解析html时，会遇到一些资源连接，此时就需要进行单独处理了

简单起见，这里将遇到的静态资源分为一下几大类（未列举所有）：

- CSS样式资源
- JS脚本资源
- img图片类资源

**遇到外链时的处理**

当遇到上述的外链时，会单独开启一个下载线程去下载资源（http1.1中是每一个资源的下载都要开启一个http请求，对应一个tcp/ip链接）

**遇到CSS样式资源**

CSS资源的处理有几个特点：

- CSS下载时异步，不会阻塞浏览器构建DOM树
- 但是会阻塞渲染，也就是在构建render时，会等到css下载解析完毕后才进行（这点与浏览器优化有关，防止css规则不断改变，避免了重复的构建）
- 有例外，`media query`声明的CSS是不会阻塞渲染的

**遇到JS脚本资源**

JS脚本资源的处理有几个特点：

- 阻塞浏览器的解析，也就是说发现一个外链脚本时，需等待脚本下载完成并执行后才会继续解析HTML
- 浏览器的优化，一般现代浏览器有优化，在脚本阻塞时，也会继续下载其它资源（当然有并发上限），但是虽然脚本可以并行下载，解析过程仍然是阻塞的，也就是说必须这个脚本执行完毕后才会接下来的解析，并行下载只是一种优化而已
- defer与async，普通的脚本是会阻塞浏览器解析的，但是可以加上defer或async属性，这样脚本就变成异步了，可以等到解析完毕后再执行

**遇到img图片类资源**

遇到图片等资源时，直接就是异步下载，不会阻塞解析，下载完毕后直接用图片替换原有src的地方

## loaded和domcontentloaded

简单的对比：

- DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片(譬如如果有async加载的脚本就不一定完成)
- load 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了

