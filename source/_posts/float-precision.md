---
title: float-precision
date: 2019-03-05 17:11:35
tags: 计算机组成原理
categories: 通用
---
## IEEF中浮点数精度问题

先看下下面例子

```
// 加法 =====================
0.1 + 0.2 = 0.30000000000000004
0.7 + 0.1 = 0.7999999999999999
0.2 + 0.4 = 0.6000000000000001

// 减法 =====================
1.5 - 1.2 = 0.30000000000000004
0.3 - 0.2 = 0.09999999999999998
 
// 乘法 =====================
19.9 * 100 = 1989.9999999999998
0.8 * 3 = 2.4000000000000004
35.41 * 100 = 3540.9999999999995

// 除法 =====================
0.3 / 0.1 = 2.9999999999999996
0.69 / 10 = 0.06899999999999999
```
<!-- more -->
> - 浮点数运算精度丢失问题并不是js独有的！
> - js浮点数的加减乘除运算都可能导致精度丢失问题！

### 原因

浮点数的表示方法，任何数在计算机面前都会被处理成二进制，而数字的二进制表示主要有原码、反码、补码。（有点熟悉对不对？哥就是来给你补计算机组成原理的，坏笑～）

#### 原码

原码是计算机中对数字的二进制的定点表示方法，最高位表示符号位，其余位表示数值位。优点显而易见，简单直观；缺点也很明显，不能直接参与运算，可能会报错，如11+(-11) => 10010110 => -22，结果竟然不等于0。（卧槽，瞎搞啊～，以为我没上过学？）所以，原码符号位不能直接参与运算。说到这，给大家个思考题，8位有符号的原码表示范围是多少？自己思考哈～

#### 反码

正数的反码和其原码一样；负数的反码，符号位为1，数值部分按原码取反。例如 [+7]原 = 00000111，[+7]反 = 00000111； [-7]原 = 10000111，[-7]反 = 11111000。

#### 补码

正数的补码和其原码一样；负数的补码为其反码加1。例如 [+7]原 = 00000111，[+7]反 = 00000111，[+7]补 = 00000111； [-7]原 = 10000111，[-7]反 = 11111000，[-7]补 = 11111001。
说到这，你也许会问，哥你这都是讲的整数啊，没说到浮点数啊。别急，弟继续往下看～

#### 浮点数的表示方法

国际标准IEEE 754规定，任意一个二进制浮点数V都可以表示成下列形式：
$$
V = （-1）^S* M * 2^E
$$

1. (-1)^s 表示符号位，当s=0，V为整数；s=1，V为负数；

2. M 表示有效数字，1≤M<2；

3. 2^E 表示指数位

   > 举个小栗子🌰：
   > -0.5 => -0.1[二进制]
   >    => -1.0 * 2^-1
   >    => (-1)^1 * 1.0 * 2^-1
   >    => s=1，M=1.0，E=-1

IEEE 754又规定了，浮点数分单精度双精度之分：

- 32位的单精度浮点数，最高1位是符号位s，接着的8位是指数E，剩下的23位是有效数字M
- 64位的双精度浮点数，最高1位是符号位s，接着的11位是指数E，剩下的52位为有效数字M

对于有效数字M和指数E，这个IEEE 754还规定了：

1. 有效数字M
   （1）1≤M<2，也即M可以写成1.xxxxx的形式，其中xxxxx表小数部分
   （2）计算机内部保存M时，默认这个数第一位总是1，所以舍去。只保存后面的xxxxx部分，节省一位有效数字
2. 指数E（阶码）
   （1）E为无符号整数。E为8位，范围是0～255；E为11位，范围是0～2047
   （2）因为科学计数法中的E是可以出现负数的，所以IEEE 754规定E的真实值必须再减去一个中间数（偏移值），127或1023

#### 实例计算（以单精度为例）

0.2  => 1.100110011001100...*2^-3 =>

0(符号位) 01111100 (指数位) (1) 10011001100110011001100(尾数位)

0.4  => 1.100110011001100...*2^-2 =>

0(符号位) 01111101 (指数位) (1) 10011001100110011001100(尾数位)

指数位为何是01111100，不是应该是-3，这是因为-3加上了中间值127等于124；所以反算的时候，要用计算值减去中间值得到真正的指数值。

（1）对阶
根据小阶对大阶原则，0.2的阶码向0.4阶码对齐，即0.4的阶码不作调整，0.2的阶码对齐，且尾数做右移处理：

0.2 => 0 01111101 (0)11001100110011001100110
0.4 => 0 01111101 (1)10011001100110011001100

（2）尾数求和
(00)11001100110011001100110 +

(01)10011001100110011001100 = 

(10)01100110011001100110010

（3）尾数规格化
0 01111101 (10)01100110011001100110010 => 0 01111110 (1)00110011001100110011001

>  **最后的0被移出去了，这就是误差产生的根源！**

（4）舍入
（5）校验判断
0.2 + 0.4 => 0 01111110 (1)00110011001100110011001 => 1.1999999285/2 => 0.5999999643 （并不等于0.6）

最后发现计算结果果然出现误差，因为在尾数规格化的步骤中可能产生移位误差，看来要想精确运算，不能直接操作浮点数运算啊！最保险的方法是在运算过程中，将浮点数处理成整数进行运算：

去除小数点，注意不要直接乘

> 35.41 * 100 = 3540.9999999999995
>
> let number = 35.41
>
> （number+'').replace('.','')-0


